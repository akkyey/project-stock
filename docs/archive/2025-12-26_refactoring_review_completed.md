# Project Refactoring Review & Proposal (2025 Edition)

## 1. 総合評価 (Executive Summary)

現在の `stock-analyzer3` プロジェクトは、機能要件（データ取得、分析、AI判定、保存）を十分に満たしており、実運用レベルにあります。特に直近の品質改善（自己診断、静的解析導入）により、安定性は大きく向上しました。

しかし、急速な機能追加により**アーキテクチャの歪み**が生じており、将来的な拡張性や保守性に課題があります。特にメインの `AntigravityRunner` クラスが巨大化（God Class化）しており、処理の流れが追いづらくなっています。

- **実用レベル:** High (安定稼働中)
- **コード品質:** Medium (機能分離はされているが、結合度が局所的に高い)
- **保守性:** Medium-Low (一部のファイルが巨大で修正影響範囲が見えにくい)

---

## 2. 現状の課題と評価 (Current Issues)

### 2.1. アーキテクチャ・構造
*   **神クラス (`AntigravityRunner`):** CLI引数の解析、ユースケース制御（Extract/Analyze/Ingest）、ファイル操作、画面表示がすべて1つのクラスに詰め込まれています。
*   **不統一な並行処理モデル:** `extract` モードでは `ThreadPoolExecutor` を使用し、`analyze` モードでは `asyncio` を使用しています。この混在はデバッグを困難にし（今回のRace Conditionの一因）、リソース管理を複雑にします。
*   **設定ファイルへの過度な依存:** `config.yaml` がビジネスロジック（スコアリングルール、バリデーションルール）のすべてを担っています。柔軟ですが、タイプミスが実行時エラーにつながるリスクがあります（Pydantic等でのバリデーションがない）。

### 2.2. 可読性・コード品質
*   **長いメソッド:** `StockAnalyzer.run_analysis` や `AntigravityRunner.analyze` など、1つのメソッドが100行を超えるケースがあり、可読性が低下しています。
*   **ロギングの散在:** `print` 文と `logger` が混在しており、本番運用時のログ監視が統一されていません。
*   **型ヒントの不完全さ:** 主要なインターフェースで型ヒント (`Type Hint`) が不足しており、IDEの補完や静的解析の恩恵を十分に受けられていません。

### 2.3. 処理効率・堅牢性
*   **DB接続管理:** `db_proxy` を使用していますが、直近の修正で生の `sqlite3` 接続や手動の `connect`/`close` が散見され、接続リークのリスクがあります。
*   **エラーハンドリング:** "Quarantine"（隔離）メカニズムは優秀ですが、Runner内でアドホックに実装されており、他のモード（Ingest等）で再利用しにくくなっています。

---

## 3. リファクタリング提案 (Proposals)

### Phase 1: 構造の整理 (Structural Cleanup) - **優先度: 高**
まず、巨大化した `AntigravityRunner` を解体し、各モードを独立した「コマンド/ユースケース」クラスに分割することを提案します。

1.  **コマンドパターンの導入:**
    -   `src/commands/extract.py`
    -   `src/commands/analyze.py`
    -   `src/commands/ingest.py`
    -   `AntigravityRunner` はこれらを呼び出すだけの薄い「ディスパッチャ」にする。

2.  **並行処理の統一 (Asyncio化):**
    -   プロジェクト全体を `asyncio` ベースに統一する。
    -   `extract` 処理（DB読み込み、Pandas処理）も非同期ラッパー経由で実行することで、Runner全体を `async def run()` で統一でき、Race Conditionのリスクを低減できます。

### Phase 2: 堅牢性の向上 (Robustness) - **優先度: 中**

3.  **Typed Configuration (Pydantic):**
    -   `config.yaml` を読み込む際に `Pydantic` モデルにマッピングする。
    -   `thresholds` や `na_allowed` のスペルミスや型違反を起動時に即座に検知できるようにする。

4.  **DBアクセスの抽象化強化:**
    -   `provider.py` にあるクエリロジックの一部を `repositories/` パターンに移行し、生SQLや複雑なJOINを隠蔽する。

### Phase 3: 実用性と効率 (Practicality) - **優先度: 低**

5.  **パイプラインアーキテクチャ:**
    -   「抽出 → 分析 → 保存」の流れを明確なパイプライン処理として定義する。
    -   中間ファイル（JSON）を経由せず、メモリ上でストリーム処理できるモード（`--pipeline stream`）を追加し、IOオーバーヘッドを削減する。

---

## 4. 改善ロードマップ案

| フェーズ   | 期間目安 | 内容                                                           | 期待効果                     |
| :--------- | :------- | :------------------------------------------------------------- | :--------------------------- |
| **Step 1** | 1-2日    | `AntigravityRunner` の分割 (Extract/Analyze/Ingest のクラス化) | 可読性向上、テスト容易性向上 |
| **Step 2** | 1日      | 設定ファイルの型定義 (Pydantic導入)                            | 設定ミスの撲滅、開発体験向上 |
| **Step 3** | 2-3日    | IO/並行処理の Asyncio 統一                                     | デバッグ容易性、安定性向上   |
| **Step 4** | 中期的   | パイプラインモードの実装                                       | 処理速度向上、ディスクIO削減 |

## 5. 結論

現状でも十分に実用的ですが、**Step 1（Runnerの分割）** と **Step 2（設定の型安全化）** は、今後の開発効率とバグ防止のために早期に実施することを強く推奨します。特に設定ミスによる障害（今回のNo.3のようなケース）は、Pydantic導入で防げる可能性が高いです。
