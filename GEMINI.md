# エージェント行動規範 (Agent Behavior Protocol)

## 1. 厳格なフェーズ管理と実行承認

すべてのタスク実行は、以下のフェーズに厳密に分割し、ユーザーの明示的な実行許可を待つこと。

1.  **調査 (Investigation):** タスクの要求、関連コードベース、および制約の初期調査を行う。
2.  **調査結果の報告 (Investigation Report):** 調査結果、提案されるアプローチ、および予想される変更の概要を提示する。
3.  **修正作業 (Implementation):** 調査結果に基づき、具体的なコード修正や設定変更を行う。
4.  **検証 (Verification):** 修正作業が完了した後、テストを実行し、意図した動作を満たしているかを確認する。
5.  **結果報告 (Final Report):** 最終的な検証結果と、タスクの完了ステータスを報告する。

### 実行の合言葉 (Execution Passphrase)

各フェーズの実行を開始する際には、ユーザーが提示する**合言葉**（例えば「`PROCEED`」や「`続行`」など）と、そのフェーズの実行を促す**指示**があった場合のみ、次のフェーズに進むこと。

### 検証失敗時の対応 (Failure Protocol)

「検証 (Verification)」フェーズでテストが失敗、または予期せぬ動作をした場合、**自動的に修正を行わない**こと。必ず失敗の原因を特定し、「調査結果の報告 (Investigation Report)」フェーズに戻ってユーザーに状況を報告し、再度の指示を仰ぐこと。

---

## 2. 不具合修正ポリシー (Defect Remediation Policy)

### 不具合検出時の動作

タスク実行中または検証フェーズで不具合（バグ、エラー、テスト失敗など）を検出した場合、**即座に修正作業を行わない**こと。

### 報告形式

検出したすべての不具合は、以下の形式で一覧としてユーザーに提示し、レポートファイルに記録すること。

* **検出時刻:** `HH:MM` 形式のタイムスタンプ。
* **通番:** その日の不具合としての連番（No.1, No.2...）を付与すること。
* **不具合の概要:** 検出された現象の簡潔な説明。
* **原因の提示:** その不具合の推定される根本原因。
* **影響 (Impact):** その不具合がシステムやユーザーに与える**影響の大きさ**を具体的に記載すること。
* **修正案 (Proposed Fix):** その不具合に対する**具体的な修正アプローチ**を提案すること。

### 修正の実行

修正作業は、ユーザーから**以下のいずれかの指示**があった場合にのみ行うこと。

* **番号指示:** 「`Fix #N`」のように**通番が指定された場合**は、その番号に対応する不具合のみを修正すること。
* **全体指示:** 「`Fix ALL`」のように**すべてを修正する指示**があった場合は、一覧に提示した不具合すべてを修正すること。

---

## 3. ファイル管理ポリシー (File Management Policy)

### テストモジュールの配置

テストコードは、プロジェクトルートに作成する専用のフォルダ内に保存すること。

* **プラットフォーム管理:** テストフォルダの内部は、**対象プラットフォームや環境**（例: `web/`, `mobile/ios/`, `backend/unit/`など）ごとにサブフォルダを作成し、管理すること。

### 障害レポートの記録 (Defect Reporting)

不具合（障害）を検出した際は、プロジェクトルートに「**`trouble`**」という名前のフォルダを作成し、以下のルールに従って記録すること。

* **ファイル名の形式:** 必ず検出日の日付を使用し、`YYYY-MM-DD-report.md` とする。(例: `2025-12-10-report.md`)
* **日次統合 (Daily Consolidation):** 該当する日付のファイルが既に存在する場合は、**新規作成せず、既存ファイルの末尾に追記（Append）**すること。ファイルが存在しない場合のみ、新規作成すること。

### 修正履歴の記録 (Modification History)

コード修正作業を実行する際には、プロジェクトルートに「**`history`**」という名前のフォルダを作成すること。

* **ファイル作成:** 履歴ファイルは、`history`フォルダ内に、修正実施日を基に `YYYY-MM-DD.md` (例: `2025-12-10.md`) の形式で作成または追記すること。
* **記録内容:** 修正を行った**対象ファイル**、**修正の概要**、および**対応した不具合の通番**を記録すること。
*   **必須事項:** ソースコードの変更を伴うすべての作業において、この履歴ファイルの作成・更新は**必須**である。コミット前には必ず履歴ファイルが更新されているかを確認すること。

---

## 4. コミュニケーションと透明性に関するルール

### コミュニケーション言語

ユーザーとのすべてのコミュニケーション（報告、質問、指示の確認など）は、**日本語**で行うこと。技術用語は英語表記を併記しても良い。
**プロポーサルなどのドキュメント作成も原則として日本語で行うこと。**

### ソースコード修正の厳格なプロセス (Strict Source Code Modification Process)

ソースコード（`src/`, `tests/` 以下のファイルなど）を修正する際は、いきなり変更ツール（`replace`, `write_file`）を実行せず、必ず以下の手順を遵守すること。

1.  **問題の特定と報告:** 修正が必要な箇所とその理由（バグの原因、リファクタリングの目的など）を特定し、ユーザーに報告する。
2.  **修正案の提示:** 具体的にどのようにコードを変更するか、**変更前後のコードブロック**や**差分（Diff）**を用いて明確に提示する。
3.  **承認の取得:** ユーザーから明示的な修正の許可（「修正して」「OK」など）を得るまで、ファイルの変更は行わないこと。
4.  **修正の実行:** 許可を得た修正案に基づき、ツールを使用してファイルを変更する。
5.  **履歴の記録:** 修正完了後、速やかに`history`フォルダ内の履歴ファイル（`YYYY-MM-DD.md`）に修正内容を記録すること。

### 変更の差分表示

「修正作業 (Implementation)」フェーズの報告、または「検証 (Verification)」後の結果報告において、コードの変更内容は**差分（Diff）形式**で簡潔かつ正確に提示すること。

### ダークモード対応の出力 (Dark Mode Accessibility)

ユーザーはダークモードを使用している可能性があるため、以下の点に配慮すること。

*   **文字色の視認性確保 (High Contrast):** ダークモードの黒背景においても文字が埋もれないよう、**文字色を白（または最高輝度のコントラスト）にする**ことを強く意識すること。
    *   Markdownの性質上、直接的な色指定が制限される場合は、**太字 (`**text**`)** や **コードブロック (` ```text `)** を使用して、必然的に白（または高輝度）の文字として表示されるように制御すること。
*   **絵文字の活用:** ステータス表示には絵文字（✅ ❌ ⚠️ 📦 など）を使用すること。これらはダークモードでも視認性が高い。
*   **HTMLカラーコードの禁止:** `<span style="color:red">` などのインラインHTMLによる色指定は、ダークモードで見えなくなるため**使用禁止**とする。
*   **コードブロックの活用:** Diff表示やコード例は必ずフェンス付きコードブロック（```diff, ```python など）を使用すること。シンタックスハイライトはテーマ対応している。
    *   **補足:** テーブルの視認性が極端に悪い場合に備え、重要な情報は必ず**テキストベースのコードブロック (` ```text `) で要約を併記**すること。

### Markdown内レビューコメントへの対応 (Handling Review Comments in Markdown)

Markdownファイル（`.md`）内において、行頭が `//` で始まる行は、ユーザーからのレビューコメントまたは修正指示として扱うこと。

1.  **指示の抽出:** ファイルの読み取り時に `//` で始まる行を特定し、その内容をタスクとして解釈する。
2.  **指示の完遂:** コメントに記載された指示（例: 修正、追加、削除など）を正確に実行する。
3.  **コメントの削除:** 指示内容の実行が完了した後、当該コメント行を削除してファイルを最終状態に整えること。

---

## 5. コードおよびドキュメントの最新化 (Code and Document Synchronization)

コードモジュールを修正した際は、対応する**設計書**を更新するとともに、必ず以下のスクリプトを実行してプロジェクト全体のコンテキストファイルおよび自己診断スクリプトを最新化すること。

*   **コンテキストファイルの生成:** `python3 full_context/generate_full_context.py`
    *   生成場所: `full_context/[YYYY-MM-DD]_project_full_context.md`
    *   このファイルは、他のAIエージェントにプロジェクトの全容を伝えるために使用される。
*   **自己診断スクリプトの更新:** `self_diagnostic.py`
    *   **重要:** 新しい機能の追加や既存コードの変更があった場合は、**必ず `self_diagnostic.py` に対応するテストを追加または更新し、コード品質が維持されていることを保証すること。**


## 6. 自動化と環境維持 (Automation & Environment Maintenance)

### Git Hook の運用と遵守

プロジェクトの品質とコンテキストの整合性を保つため、`.git/hooks/pre-commit` に自動化スクリプトを配置し、コミット時に以下の処理を強制的に実行すること。

1.  **自己診断の実行 (Self-Diagnostic):**
    * コミット前に必ず `python self_diagnostic.py` を実行する。
    * テストが失敗した場合、コミットは**拒否**されなければならない。

2.  **コンテキストの自動更新 (Context Auto-Update):**
    * コミットに含まれる変更が `src/`, `docs/`, `config.yaml` 等の仕様に関わるものである場合、自動的に `generate_full_context.py` (または `generate_context.py`) を実行する。
    * 生成された最新のコンテキストファイル（例: `project_context.md`）を自動的にステージングし、同一のコミットに含めること。

---

## 7. コマンド実行の安全性 (Command Safety)

### Gitコミットメッセージの取り扱い (Git Commit Messages)

シェルによる意図しないコマンド実行（コマンド置換など）を防ぐため、コミットメッセージを指定する際は以下の手順を遵守すること。

1.  **直接指定の禁止:** `git commit -m "message"` の形式で、シェルコマンド内に直接メッセージを含めることは、メッセージ内に特殊文字（バッククォート等）が含まれる可能性があるため**原則禁止**とする。
2.  **ファイル経由の指定:** 必ずコミットメッセージを一時ファイルに保存し、`-F` オプションを使用して読み込むこと。

    **実行手順例:**
    ```bash
    # 1. メッセージを一時ファイルに作成
    cat <<EOF > .git_commit_msg
    feat: 機能追加

    詳細な説明文（バッククォート `code` も使用可能）
    EOF

    # 2. ファイルを指定してコミット
    git commit -F .git_commit_msg

    # 3. 一時ファイルを削除
    rm .git_commit_msg
    ```
## 8. カバレッジテストに関する規定 (Coverage Testing Policy)

プログラムの改変を行う際は、必ずカバレッジテスト環境 ( 等) への反映を行うこと。

1.  **テストの実装:** 新規機能やロジック変更に対して、十分なカバレッジを持つテストケースを作成・更新すること。
2.  **カバレッジの確認:**  (または同等のスクリプト) を実行し、カバレッジレポートを確認すること。
3.  **低下の防止:** 原則として、既存のカバレッジ率を低下させないように努めること。

---

## 9. バックログ管理 (Backlog Management)

### バックログへの記録基準

提案された機能や修正案のうち、以下の理由で実装を見送ったものは、必ずバックログリスト (`docs/backlog.md`) に記録すること。

*   時期尚早と判断されたもの。
*   優先順位の変更により延期されたもの。
*   技術的な課題や依存関係により即時実装が困難なもの。

### 記録内容

バックログには、各項目について以下の情報を記載すること。
*   **ID** バックログ内でユニークな番号。
*   **ステータス:** 保留中 (Pending) / 検討中 (On Hold) など。
*   **起案日:** バックログに追加した日付。
*   **関連提案:** 関連する提案資料やドキュメントへのリンク。
*   **概要:** 機能や修正の内容。
*   **保留理由:** なぜ今回実装を見送ったのか、その理由。

---

## 10. 無限修正ループの防止 (Prevention of Infinite Modification Loops)

### ループ検知基準

同一または類似の修正が、短期間に**2回以上**繰り返され、かつ解決に至らない場合、「無限修正ループ」に陥っていると判断すること。
（例：修正A → テスト失敗 → 修正Aの取り消し/修正B → テスト失敗 → 再度修正Aを適用... のような状況）

### 直ちに停止と再調査

ループを検知した際は、**即座にその修正作業を停止**し、以下の手順をとること。

1.  **盲目的な再試行の禁止:** 前回の修正を少し変えて再試行するだけの行為は禁止する。
2.  **原因の深掘り (Deep Dive):** なぜその修正が機能しないのか、根本原因を再調査する（例：隠れた依存関係、テスト自体の誤り、環境の差異など）。
3.  **代替案の提示:** 既存のアプローチが通用しないことを認め、全く異なるアプローチや解決策をユーザーに提案する。

---

## 11. プロポーサルの管理 (Proposal Management)

### アーカイブ化の基準
実装が完了し、検証を通過したプロポーサル（`docs/proposal/*.md`）は、速やかにアーカイブディレクトリ（`docs/archive/`）へ移動すること。

*   **目的:** `docs/proposal/` フォルダを常に「現在進行形」または「未着手」の提案のみが含まれる状態に保ち、プロジェクトの進捗状況を明確にするため。
*   **管理:** アーカイブへ移動する際は、必要に応じてステータスを「完了 (Implemented)」等に更新した上で移動すること。

---

## 12. 改造時の結果整合性検証 (Modified Code Integrity Verification)

### 結果の一致確認の義務化
リファクタリング、パフォーマンス最適化、または基盤コードの改変を行う際は、必ず**改造前後で同一の入力データを用い、最終的な出力結果（CSV, Excel, DBレコード等）が完全に一致すること**を物理的に検証しなければならない。

### 一致不可能な場合の対応
プログラムの性質上、または意図した仕様変更により、改造前後で結果を完全に一致させることが不可能な場合には、以下の手順を遵守すること。

1.  **即時報告:** 一致させられない理由（例：計算精度の向上、浮動小数点の挙動差異、仕様変更の必然性など）を明確にし、ユーザーに報告する。
2.  **指示の要請:** 差分の許容範囲や、新しい結果を「正」として受理するかについて、ユーザーからの具体的な指示を仰ぐこと。
3.  **独自判断の禁止:** ユーザーの明示的な許可なく、「微差だから問題ない」と判断して作業を続行してはならない。

---

## 13. 静的解析ツールの実行 (Static Analysis Execution)

### 変更時の義務
プログラムを変更した際は、必ず静的解析ツールを実行し、コード品質を維持すること。

1.  **実行タイミング:** コード修正後、コミットまたはレビュー依頼を行う前。
2.  **実行ツール:**
    *   **Formatting:** `black .` (コードの自動整形)
    *   **Lint:** `ruff check .` (高速Lint & Import整理)
    *   **Type Check:** `mypy` (推奨設定: `ignore_missing_imports = True`)
    *   **Legacy Lint:** `flake8` (移行期間中のみ併用)
3.  **対応:** 検出されたエラーや警告は、修正するか、正当な理由がある場合は明示的に無視（`# noqa` 等）し、その理由を記録すること。

---

## 14. Python 実行環境 (Python Execution Environment)

### 仮想環境の使用義務

すべての Python コマンド（`python`, `pip`, `pytest`, `mypy` 等）の実行において、プロジェクト専用の仮想環境を使用すること。

### 仮想環境パス

```
/home/irom/project-stock2/venv
```

### 実行方法

以下のいずれかの方法で仮想環境を使用すること。

1.  **アクティベート方式**（推奨）:
    ```bash
    source /home/irom/project-stock2/venv/bin/activate
    python <script>
    pip install <package>
    ```

2.  **直接パス指定**:
    ```bash
    /home/irom/project-stock2/venv/bin/python <script>
    /home/irom/project-stock2/venv/bin/pip install <package>
    ```

### 禁止事項

*   **システムの `python3` / `pip3` を直接使用することは禁止**。
*   `/usr/bin/python3` や `/usr/bin/pip3` が使用された場合、依存パッケージの不整合やテスト失敗の原因となる。

### 確認方法

コマンド実行前に、使用している Python のパスを確認すること。

```bash
which python3  # 期待値: /home/irom/project-stock2/venv/bin/python3
```
## 15. バージョン管理とブランチ運用 (Git Flow & Branch Management)

### 基本方針 (Core Principles)
1.  **永続ブランチは `main` のみ:** 常に最新の安定版を反映し、いつでも利用可能な状態を保つ。
2.  **作業ブランチはすべて「使い捨て」:** 機能追加や修正ごとに短命のブランチを作成し、マージ後に即時削除する。

### 推奨ワークフロー (Design Review PR Flow)
タスク開始時に以下のステップを踏むことで、設計の合意形成と履歴のクリーンさを担保する。

1.  **ブランチ作成:**
    *   タスクの内容に応じたブランチを作成する。
    *   命名規則: `feat/feature-name` (機能追加), `fix/bug-fix` (修正), `docs/update-docs` (ドキュメント)
    *   コマンド例: `git checkout -b feat/add-new-feature`

2.  **計画書の作成とPush (Design Proposal):**
    *   コード実装の前に、まず設計書 (`docs/proposal/xxx.md`) や計画書 (`implementation_plan.md`) のみを作成・更新し、Commit & Pushを行う。
    *   **この段階で Pull Request (Draft) を作成することを推奨する。**

3.  **レビューと合意 (Review & Approve):**
    *   GitHub上でユーザー（レビュアー）と計画内容について議論し、合意形成（Approve）を得る。

4.  **実装 (Implementation):**
    *   承認されたら、**同一のブランチ**でコードの実装を行う。

5.  **マージと削除 (Merge & Delete):**
    *   実装完了後、PRを `main` ブランチにマージする。
    *   マージ後、**作業ブランチは必ず削除する**（GitHubの自動削除機能を推奨）。
