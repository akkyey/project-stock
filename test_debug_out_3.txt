============================= test session starts ==============================
platform linux -- Python 3.12.3, pytest-9.0.2, pluggy-1.6.0 -- /mnt/d/dev2/project-stock2/venv/bin/python3
cachedir: .pytest_cache
rootdir: /mnt/d/dev2/project-stock2
configfile: pytest.ini
plugins: anyio-4.12.0, cov-7.0.0
collecting ... collected 13 items

tests/test_commands.py::TestExtractCommand::test_execute_no_candidates PASSED
tests/test_commands.py::TestExtractCommand::test_execute_with_candidates DEBUG: output_path /tmp/tmp3ujq7lj2/test_output.json DOES NOT EXIST
DEBUG: Quarantine files: []
FAILED
tests/test_commands.py::TestAnalyzeCommand::test_execute_no_candidates PASSED
tests/test_commands.py::TestAnalyzeCommand::test_execute_processes_candidates FAILED
tests/test_commands.py::TestIngestCommand::test_execute_ingest_valid_json PASSED
tests/test_commands.py::TestIngestCommand::test_execute_no_files PASSED
tests/test_commands.py::TestIngestCommand::test_export_to_csv_chunking PASSED
tests/test_commands.py::TestIngestCommand::test_export_to_csv_no_results PASSED
tests/test_commands.py::TestIngestCommand::test_export_to_csv_with_data PASSED
tests/test_sentinel_orchestrator_integration.py::TestSentinelOrchestratorIntegration::test_sentinel_alert_generation FAILED
tests/test_sentinel_orchestrator_integration.py::TestSentinelOrchestratorIntegration::test_orchestrator_daily_flow FAILED
tests/test_sentinel_orchestrator_integration.py::TestSentinelOrchestratorIntegration::test_orchestrator_weekly_flow DEBUG: Reporter Output Dir: data/output
DEBUG: Saving Summary to data/output/weekly_report_20260105_1652.csv
PASSED
tests/test_sentinel_orchestrator_integration.py::TestSentinelOrchestratorIntegration::test_orchestrator_balanced_refresh DEBUG: Reporter Output Dir: data/output
PASSED

=================================== FAILURES ===================================
_______________ TestExtractCommand.test_execute_with_candidates ________________

self = <test_commands.TestExtractCommand testMethod=test_execute_with_candidates>
mock_to_thread = <AsyncMock name='to_thread' id='133691506873152'>
mock_validator_cls = <MagicMock name='ValidationEngine' id='133691506979472'>
mock_agent_cls = <MagicMock name='AIAgent' id='133691507049344'>
mock_db_cls = <MagicMock name='StockDatabase' id='133691507053136'>
mock_provider_cls = <MagicMock name='DataProvider' id='133691507056928'>
mock_engine_cls = <MagicMock name='AnalysisEngine' id='133691507060720'>

    @patch("src.engine.AnalysisEngine")
    @patch("src.provider.DataProvider")
    @patch("src.database.StockDatabase")
    @patch("src.commands.extract.AIAgent")
    @patch("src.commands.extract.ValidationEngine")
    @patch("asyncio.to_thread")
    def test_execute_with_candidates(
        self,
        mock_to_thread,
        mock_validator_cls,
        mock_agent_cls,
        mock_db_cls,
        mock_provider_cls,
        mock_engine_cls,
    ):
        """execute should process candidates and save valid tasks."""
        # Setup to_thread to run sync but be awaitable
        async def mock_to_thread_side_effect(f, *args, **kwargs):
            return f(*args, **kwargs)
        mock_to_thread.side_effect = mock_to_thread_side_effect
    
        from src.commands.extract import ExtractCommand
    
        # Setup mocks
        df = pd.DataFrame(
            [
                {
                    "code": "1001",
                    "name": "Test",
                    "quant_score": 80,
                    "sector": "Tech",
                    "market_data_id": 1,
                    # Tier 1 Required
                    "current_price": 1000,
                    "operating_cf": 500,
                    "operating_margin": 10,
                    "per": 15,
                    "pbr": 1.2,
                    "roe": 10,
                }
            ]
        )
        mock_provider = MagicMock()
        mock_provider.load_latest_market_data.return_value = df
        mock_provider.stock_db = MagicMock()
        mock_provider_cls.return_value = mock_provider
    
        mock_db = MagicMock()
        mock_db.get_ai_cache.return_value = None
        mock_db.get_market_data_id.return_value = 1
        mock_db_cls.return_value = mock_db
    
        mock_agent = MagicMock()
        mock_agent._create_prompt.return_value = "Test Prompt"
        mock_agent_cls.return_value = mock_agent
    
        mock_validator = MagicMock()
        mock_validator.validate.return_value = (True, None)  # Valid
        mock_validator_cls.return_value = mock_validator
    
        mock_engine = MagicMock()
        mock_engine.calculate_scores.return_value = df
        mock_engine.filter_and_rank.return_value = df
        mock_engine_cls.return_value = mock_engine
    
        with tempfile.TemporaryDirectory() as tmpdir:
            cmd = ExtractCommand(get_mock_config(), debug_mode=True)
            cmd.interim_dir = tmpdir
            output_path = os.path.join(tmpdir, "test_output.json")
    
            cmd.execute(strategy="test_strategy", limit=5, output_path=output_path)
    
            # DEBUG: check results? If valid_tasks was empty, file won't exist.
            if not os.path.exists(output_path):
                print(f"DEBUG: output_path {output_path} DOES NOT EXIST")
                # Check quarantine?
                import glob
                q_files = glob.glob(os.path.join(tmpdir, "quarantine/*"))
                print(f"DEBUG: Quarantine files: {q_files}")
                for qf in q_files:
                    with open(qf, "r") as f:
                        print(f"DEBUG: Quarantine content: {f.read()}")
    
            # Verify output file exists
>           self.assertTrue(os.path.exists(output_path))
E           AssertionError: False is not true

tests/test_commands.py:160: AssertionError
_____________ TestAnalyzeCommand.test_execute_processes_candidates _____________

self = <test_commands.TestAnalyzeCommand testMethod=test_execute_processes_candidates>
mock_to_thread = <AsyncMock name='to_thread' id='133691507160704'>
mock_writer_cls = <MagicMock name='ResultWriter' id='133691507182288'>
mock_agent_cls = <MagicMock name='AIAgent' id='133691507143360'>
mock_db_cls = <MagicMock name='StockDatabase' id='133691507145568'>
mock_provider_cls = <MagicMock name='DataProvider' id='133691507136736'>
mock_engine_cls = <MagicMock name='AnalysisEngine' id='133691507140336'>

    @patch("src.engine.AnalysisEngine")
    @patch("src.provider.DataProvider")
    @patch("src.database.StockDatabase")
    @patch("src.commands.analyze.AIAgent")
    @patch("src.commands.analyze.ResultWriter")
    @patch("asyncio.to_thread")
    def test_execute_processes_candidates(
        self,
        mock_to_thread,
        mock_writer_cls,
        mock_agent_cls,
        mock_db_cls,
        mock_provider_cls,
        mock_engine_cls,
    ):
        """execute should process candidates with AI agent and save results."""
        # Setup to_thread to run sync but be awaitable
        async def mock_to_thread_side_effect(f, *args, **kwargs):
            return f(*args, **kwargs)
        mock_to_thread.side_effect = mock_to_thread_side_effect
    
        from src.commands.analyze import AnalyzeCommand
    
        # Mocks
        df = pd.DataFrame(
            [
                {
                    "code": "2001",
                    "name": "AnalyzeTest",
                    "quant_score": 75,
                    "sector": "Retail",
                    "market_data_id": 2,
                    # Tier 1 Required
                    "current_price": 2000,
                    "operating_cf": 1000,
                    "operating_margin": 15,
                    "per": 12,
                    "pbr": 1.5,
                    "roe": 12,
                    "ocf_margin": 10,
                    "equity_ratio": 50,  # [v2.0] used in is_abnormal
                }
            ]
        )
    
        mock_provider = MagicMock()
        mock_provider.load_latest_market_data.return_value = df
        mock_provider.get_ai_cache.return_value = (None, "hash123")  # No cache
        mock_provider.stock_db = MagicMock()
        mock_provider_cls.return_value = mock_provider
    
        mock_db = MagicMock()
        mock_db_cls.return_value = mock_db
    
        mock_agent = MagicMock()
        mock_agent.analyze.return_value = {
            "ai_sentiment": "Bullish",
            "ai_reason": "Good",
        }
        mock_agent.get_total_calls.return_value = 0
        mock_agent_cls.return_value = mock_agent
    
        mock_writer = MagicMock()
        mock_writer_cls.return_value = mock_writer
    
        mock_engine = MagicMock()
        mock_engine.calculate_scores.return_value = df
        mock_engine.filter_and_rank.return_value = df
        mock_engine_cls.return_value = mock_engine
    
        cmd = AnalyzeCommand(get_mock_config(), debug_mode=True)
        cmd.execute(strategy="test_strategy", limit=1)
    
        # Verify AI analyze was called
>       mock_agent.analyze.assert_called_once()

tests/test_commands.py:267: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <MagicMock name='AIAgent().analyze' id='133691507054288'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'analyze' to have been called once. Called 0 times.

/usr/lib/python3.12/unittest/mock.py:923: AssertionError
______ TestSentinelOrchestratorIntegration.test_sentinel_alert_generation ______

self = <test_sentinel_orchestrator_integration.TestSentinelOrchestratorIntegration object at 0x79977bdcacf0>

    def test_sentinel_alert_generation(self):
        """Verify Sentinel generates alerts for volatility and rank changes."""
    
        # 1. Setup Data
        with db_proxy.atomic():
            Stock.create(code="9999", name="TestCorp", sector="Tech", market="Prime")
            AnalysisResult.create(
                market_data=MarketData.create(
                    code="9999", price=1000, entry_date="2025-01-01"
                ),
                strategy_name="test_strat",
                quant_score=90,
>               analyzed_at=get_current_time() - timedelta(days=7), # Set to a past date
                                                 ^^^^^^^^^
            )
E           NameError: name 'timedelta' is not defined

tests/test_sentinel_orchestrator_integration.py:91: NameError
_______ TestSentinelOrchestratorIntegration.test_orchestrator_daily_flow _______

self = <test_sentinel_orchestrator_integration.TestSentinelOrchestratorIntegration object at 0x79977bb6e750>

    def test_orchestrator_daily_flow(self):
        """Verify Orchestrator processes alerts and generates report."""
    
        # 1. Setup Alerts
        SentinelAlert.create(
            code="8888",
            alert_type="volatility",
            alert_message="Test Volatility",
            detected_at=get_current_time(),
        )
    
        # 2. Setup Analysis Result for Reporting
        with db_proxy.atomic():
            Stock.create(code="8888", name="OrchCorp", sector="Tech", market="Prime")
            md = MarketData.create(
                code="8888",
                price=2000,
                trend_score=3,
                macd_hist=0.5,
                # Essential financial data for validation
                sales=10000,
                operating_cf=1000,
                operating_margin=10.0,
                debt_equity_ratio=0.5,
                free_cf=500.0,
                volatility=0.2,
                roe=10.0,
                per=15.0,
                pbr=1.5,
                equity_ratio=50.0,
                entry_date="2025-01-01",
            )
            # 4. Create an older analysis result (manual)
            # Use 'Balanced Strategy' to match orchestrator config
            AnalysisResult.create(
                market_data=md,
                strategy_name="Balanced Strategy",
                quant_score=85,
                ai_sentiment="Bullish",
>               analyzed_at=get_current_time() - timedelta(days=1),  # Yesterday
                                                 ^^^^^^^^^
            )
E           NameError: name 'timedelta' is not defined

tests/test_sentinel_orchestrator_integration.py:191: NameError
=========================== short test summary info ============================
FAILED tests/test_commands.py::TestExtractCommand::test_execute_with_candidates
FAILED tests/test_commands.py::TestAnalyzeCommand::test_execute_processes_candidates
FAILED tests/test_sentinel_orchestrator_integration.py::TestSentinelOrchestratorIntegration::test_sentinel_alert_generation
FAILED tests/test_sentinel_orchestrator_integration.py::TestSentinelOrchestratorIntegration::test_orchestrator_daily_flow
========================= 4 failed, 9 passed in 20.91s =========================
